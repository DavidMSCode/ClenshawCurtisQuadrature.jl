var documenterSearchIndex = {"docs":
[{"location":"#ClenshawCurtisQuadrature.jl-Documentation","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"","category":"section"},{"location":"#Summary","page":"ClenshawCurtisQuadrature.jl Documentation","title":"Summary","text":"","category":"section"},{"location":"","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"ClenshawCurtisQuadrature.jl is a Julia package that provides tools for performing Clenshaw-Curtis quadrature, a numerical integration technique. This method is particularly useful for quickly integrating arbitrary functions with high accuracy. The package aims to offer efficient and easy-to-use functions for integration tasks.","category":"page"},{"location":"#Installation","page":"ClenshawCurtisQuadrature.jl Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"ClenshawCurtisQuadrature.jl is currently in development and not included in any package registries. Users will need to manually add the package with this Github repository url","category":"page"},{"location":"","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"julia> Using Pkg; Pkg.add(url=\"https://github.com/DavidMSCode/ClenshawCurtisQuadrature.jl\")","category":"page"},{"location":"","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"or enter the package manager with ","category":"page"},{"location":"","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"julia> ]","category":"page"},{"location":"","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"and run","category":"page"},{"location":"","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"(@environment) pkg> add https://github.com/DavidMSCode/ClenshawCurtisQuadrature.jl","category":"page"},{"location":"#Usage","page":"ClenshawCurtisQuadrature.jl Documentation","title":"Usage","text":"","category":"section"},{"location":"","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"The purpose of this module is to numerically solve integrals of the form","category":"page"},{"location":"","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"F(tau) = F(-1) + int_-1^1f(tau)dtau","category":"page"},{"location":"","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"where f(tau) is an integrand that is valid on the domain [-1,1] and F(tau) is an antiderivative of the integrand. ","category":"page"},{"location":"","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"note: Note\nIf F(tau) is an antiderivative of f(tau), then F(tau)+c is also an antiderivative of f(tau) for any constant value c. But, if F(-1) is known, then there is only one antiderivative that satisfies the integral.","category":"page"},{"location":"#Methods","page":"ClenshawCurtisQuadrature.jl Documentation","title":"Methods","text":"","category":"section"},{"location":"","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.jl Documentation","text":"interpolate(taus::AbstractVector{<:Real}, N::Integer; recursive::Bool = false)\nclenshaw_curtis_nested_ivpd(N::Integer, M::Integer, d::Integer)\nclenshaw_curtis_ivpi(N::Integer, M::Integer)\nclenshaw_curtis_ivpii(N::Integer, M::Integer)","category":"page"},{"location":"#ClenshawCurtisQuadrature.interpolate-Tuple{AbstractVector{<:Real}, Integer}","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.interpolate","text":"interpolate(τs::AbstractVector{<:Real}, N::Integer; recursive::Bool = false)\n\nComputes a matrix of Chebyshev polynomials of the first kind T_n(τ) for  τ  τs and n = 01N. Used with Chebyshev coefficients to  calculate the value of the interpolating polynomials at the given values of  τ.\n\nArguments\n\nτs::AbstractVector{<:Real}: The points at which to evaluate the Chebyshev\n\npolynomials.\n\nN::Integer: The polynomial degree.\nrecursive::Bool: If true, use the recursive formula to compute the\n\nChebyshev polynomials within the domain [-1,1]. If false, use the trigonometric formulation. Default is false.\n\nReturns\n\nTs: A matrix of Chebyshev polynomial values at the given values of τ.\n\n\n\n\n\n","category":"method"},{"location":"#ClenshawCurtisQuadrature.clenshaw_curtis_nested_ivpd-Tuple{Integer, Integer, Integer}","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.clenshaw_curtis_nested_ivpd","text":"clenshaw_curtis_nested_ivpd(d::Integer, N::Integer, M::Integer=N)\n\nCompute the Clenshaw-Curtis quadrature and Chebyshev basis function matrices for an Nth degree polynomial and for a d-th order integral on the interval [-1,1].\n\nArguments\n\nd::Integer: The integral order.\nN::Integer: The polynomial degree.\nM::Integer: The sampling degree. Must be greater than or equal to the\n\npolynomial degree. The integrand is evaluated at M+1 cosine spaced nodes. Defaults to N.\n\nReturns\n\nA: The Least Squares Operator matrix.\nP: The Quadrature Matrix.\nT: The Chebyshev Matrix.\n\n\n\n\n\n","category":"method"},{"location":"#ClenshawCurtisQuadrature.clenshaw_curtis_ivpi-Tuple{Integer, Integer}","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.clenshaw_curtis_ivpi","text":"clenshaw_curtis_ivpi(N::Integer, M::Integer=N)\n\nCompute the Clenshaw-Curtis quadrature and Cebyshev basis function matrices for a first order initial value problem on the interval [-1,1].\n\nArguments\n\nN::Integer: The polynomial degree.\nM::Integer: The sampling degree. Must bes greater than or equal to the\n\npolynomial degree. This is equal to the total number of function sampling points minus 1. Defaults to N.\n\nReturns\n\nA: The Least Squares Operator matrix.\nTa: The \"acceleration\" Chebyshev Matrix.\nP1: The Quadrature Matrix for acceleration to velocity.\nT1: The \"Velocity\" Chebyshev Matrix.\n\n\n\n\n\n","category":"method"},{"location":"#ClenshawCurtisQuadrature.clenshaw_curtis_ivpii-Tuple{Integer, Integer}","page":"ClenshawCurtisQuadrature.jl Documentation","title":"ClenshawCurtisQuadrature.clenshaw_curtis_ivpii","text":"clenshaw_curtis_ivpii(N::Integer, M::Integer=N)\n\nCompute the Clenshaw-Curtis quadrature and Cebyshev basis function matrices for a second order initial value problem on the interval [-1,1].\n\nArguments\n\nN::Integer: The polynomial degree.\nM::Integer: The sampling degree. Must bes greater than or equal to the\n\npolynomial degree. This is equal to the total number of function sampling points minus 1. Defaults to N.\n\nReturns\n\nA: The Least Squares Operator matrix.\nTa: The \"acceleration\" Chebyshev Matrix.\nP1: The Quadrature Matrix for acceleration to velocity.\nT1: The \"Velocity\" Chebyshev Matrix.\nP2: The Quadrature Matrix for velocity to position.\nT2: The \"Position\" Chebyshev Matrix.\n\nExample\n\nN = 5\nM = 5\nA, Ta, P1, T1, P2, T2 = clenshaw_curtis_ivpii(N, M)\n\n\n\n\n\n","category":"method"}]
}
